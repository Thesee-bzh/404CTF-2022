#From https://gist.github.com/jackz314/09cf253d3451f169c2dbb6bbfed73782

# Solves multi prime rsa given n, e, and c. Need to factor n into primes first (recommend yafu)
# Reference https://crypto.stackexchange.com/questions/31109/rsa-enc-decryption-with-multiple-prime-modulus-using-crt
# From https://github.com/diogoaj/ctf-writeups/tree/master/2018/Timisoara/crypto/NotYourAverageRSA

# Params
n = 264260849184973464982616810011189432725471679851535970549752992980013685427054130834600835230399904802462965456974947538318213223585436360002292504595152950137188712696208597449140460215140901426523911789537180980494972189978839047835537352914856104135490608512555869141766081593589643441958443651294711541856201978508340915671607277979591968248058399795168563294090427290234733756922544755667413890558324220843460177193246018531280862561066074120654752753002311679435459237771670352371010596105395795940209523309781850979927988566194373203050532192192865140293356042897510103979797577385050030819647066037181
e = 65537
c = 40110232492214007673187408092050413824057587648366839143339482691859337096033351102276645395275735274322548715598894335826499267358923539936373981416212599523632227239475760261528220077888121552688286380591552417803111794635687206274867498165659330678667435332328065173075710535404048653621228158847748005294255562046654937629633514846123655978199420228460405580305729253303227936760801772396770804796700223239015341586701669475537453700175448572495847377417335800300005252499067811919833639526361733535793115856365357616339193637149185654816751038389408567777725988888990153670326115611236718811592564298263

# From http://factordb.com, we can factorize n: it has 64 prime numbers !
primes = [ 2155535293, 2199478601, 2295459937, 2322429719, 2339050229, 2379443669, 2389392361, 2436205657, 2462984113, 2516886503, 2547151627, 2635311961, 2686629157, 2738125309, 2778293267, 2778911501, 2800829821, 2879122817, 2880934613, 2886660797, 2898630157, 2900891821, 2908514743, 2911937201, 2917907323, 2952780151, 2966345311, 3103669319, 3103875457, 3132223999, 3166178749, 3184079849, 3206428061, 3222160589, 3223685581, 3232212233, 3356051399, 3426525181, 3560494649, 3563338969, 3581219329, 3585015977, 3667357531, 3706613399, 3729776389, 3806038133, 3837412127, 3867368123, 3889812197, 3892296953, 3921428509, 3939808331, 3976581139, 4023565787, 4103248031, 4106593759, 4157125969, 4168849637, 4191669737, 4236657239, 4242244397, 4249725811, 4254782471, 4277613239 ]

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

ts = []
xs = []
ds = []

for i in range(len(primes)):
	ds.append(modinv(e, primes[i]-1))

m = primes[0]

for i in range(1, len(primes)):
	ts.append(modinv(m, primes[i]))
	m = m * primes[i]

for i in range(len(primes)):
	xs.append(pow((c%primes[i]), ds[i], primes[i]))

x = xs[0]
m = primes[0]

for i in range(1, len(primes)):
	x = x + m * ((xs[i] - x % primes[i]) * (ts[i-1] % primes[i]))
	m = m * primes[i]


hex_ = hex(x%n)[2::]
print(bytes.fromhex(hex_).decode())

# 404CTF{F41t35_4tt3t10n5_4v3c_l3_R54}
